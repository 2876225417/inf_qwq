#include <onnxruntime_cxx_api.h>
#include <opencv2/opencv.hpp>
#include <vector>
#include <algorithm>

class ort_inferer {
public:
    /**
     * 构造函数初始化ONNX运行环境
     * @param model_path ONNX模型路径
     * @param model_height 模型输入高度（默认48）
     * @param input_nodes 输入节点名称（默认"x"）
     * @param output_nodes 输出节点名称（默认CRNN输出节点）
     * @param intra_op_num_threads 线程数（默认1）
     */
    ort_inferer(const std::string& model_path,
                int model_height = 48,
                const std::vector<std::string>& input_nodes = { "x" },
                const std::vector<std::string>& output_nodes = { "save_infer_model/scale_0.tmp_0" },
                int intra_op_num_threads = 1) :
        env(ORT_LOGGING_LEVEL_WARNING, "DigitRecognition"),
        session_options(),
        session(env, model_path.c_str(), session_options),
        memory_info(Ort::MemoryInfo::CreateCpu(OrtAllocatorType::OrtArenaAllocator, OrtMemType::OrtMemTypeDefault)),
        model_height(model_height)
    {
        session_options.SetIntraOpNumThreads(intra_op_num_threads);
        
        // 转换节点名称为C字符串
        for (const auto& s : input_nodes) input_names.push_back(s.c_str());
        for (const auto& s : output_nodes) output_names.push_back(s.c_str());
    }

    /**
     * 执行图像数字识别
     * @param image_path 要识别的图像路径
     * @return 识别结果字符串
     * @throws std::runtime_error 图像加载失败或推理错误
     */
    std::string infer(const std::string& image_path) {
        // 预处理图像
        cv::Mat input_blob = preprocess_image(image_path);
        
        // 构造输入Tensor
        std::vector<int64_t> input_shape = { 1, 3, model_height, input_blob.size[3] };
        Ort::Value input_tensor = Ort::Value::CreateTensor<float>(
            memory_info,
            input_blob.ptr<float>(),
            input_blob.total(),
            input_shape.data(),
            input_shape.size()
        );

        // 执行推理
        auto outputs = session.Run(
            Ort::RunOptions{ nullptr },
            input_names.data(),
            &input_tensor,
            1,
            output_names.data(),
            1
        );

        if (outputs.empty() || !outputs[0].IsTensor()) {
            throw std::runtime_error("推理输出异常");
        }

        // 解码输出结果
        return decode_output(outputs[0]);
    }

private:
    // 预处理函数（BGR转RGB、保持比例缩放、归一化）
    cv::Mat preprocess_image(const std::string& image_path) {
        cv::Mat img = cv::imread(image_path);
        if (img.empty()) throw std::runtime_error("加载图像失败: " + image_path);

        cv::cvtColor(img, img, cv::COLOR_BGR2RGB);
        float scale = static_cast<float>(model_height) / img.rows;
        cv::resize(img, img, cv::Size(static_cast<int>(img.cols * scale), model_height));

        img.convertTo(img, CV_32F, 1.0 / 255.0);
        std::vector<cv::Mat> channels(3);
        cv::split(img, channels);

        cv::Mat blob;
        cv::vconcat(channels[0].reshape(1, 1), channels[1].reshape(1, 1), blob);
        cv::vconcat(blob, channels[2].reshape(1, 1), blob);
        return blob.reshape(1, { 1, 3, model_height, static_cast<int>(img.cols * scale) });
    }

    // 解码输出张量为字符串
    std::string decode_output(Ort::Value& output_tensor) const {
        float* data = output_tensor.GetTensorMutableData<float>();
        auto shape = output_tensor.GetTensorTypeAndShapeInfo().GetShape();

        std::vector<int> predictions;
        for (int t = 0; t < shape[1]; ++t) {
            auto start = data + t * shape[2];
            predictions.push_back(std::max_element(start, start + shape[2]) - start);
        }

        std::string result;
        int last = -1;
        for (int idx : predictions) {
            const int adjusted = idx - 1;  // 索引偏移调整
            if (adjusted >= 0 && adjusted < char_mapping.size() && adjusted != last) {
                result += char_mapping[adjusted];
                last = adjusted;
            }
        }
        return result;
    }

    // 成员变量
    Ort::Env env;
    Ort::SessionOptions session_options;
    Ort::Session session;
    Ort::MemoryInfo memory_info;
    int model_height;
    std::vector<const char*> input_names;
    std::vector<const char*> output_names;

    // 字符映射表
    inline static const std::vector<char> char_mapping = {
        '-', '.', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'
    };
};
